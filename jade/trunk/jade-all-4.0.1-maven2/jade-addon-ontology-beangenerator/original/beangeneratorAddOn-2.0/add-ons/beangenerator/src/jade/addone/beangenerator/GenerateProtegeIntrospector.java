/******************************************************************
 * JADE - Java Agent DEvelopment Framework is a framework to develop
 * multi-agent systems in compliance with the FIPA specifications.
 * Copyright (C) 2002 TILAB S.p.A.
 *
 * This file is donated by Y'All B.V. to the JADE project.
 *
 *
 * GNU Lesser General Public License
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation,
 * version 2.1 of the License.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA  02111-1307, USA.
 * ***************************************************************/

package jade.addone.beangenerator;

/**
 *@author     C.J. van Aart - Y'All B.V.
 *@created    July 17, 2004
 *@version    1.0
 */


public class GenerateProtegeIntrospector {

  public static void Generate(String packageName, String dir) {

    StringBuffer sb = new StringBuffer("package " + packageName + ";\n\n");
    sb.append("/* This is file is generated by the ontology bean generator.  \nDO NOT EDIT, UNLESS YOU ARE REALLY REALLY SURE WHAT YOU ARE DOING! */\n\n");
    sb.append("/** file: ProtegeIntrospector\n");
    sb.append(" * @author ontology bean generator (Y'All BV) \n");
    sb.append(" * @version " + OntologyBeanGeneratorUtil.getDate() + "\n");
    sb.append(" */\n");

    sb.append("\n");
    sb.append("import java.lang.reflect.*;\n");
    sb.append("\n");
    sb.append("import jade.content.*;\n");
    sb.append("import jade.content.abs.*;\n");
    sb.append("import jade.content.onto.*;\n");
    sb.append("import jade.content.schema.*;\n");
    sb.append("import jade.core.CaseInsensitiveString;\n");
    sb.append("import jade.util.leap.Iterator;\n");
    sb.append("import jade.util.leap.List;\n");
    sb.append("\n");
    sb.append("\n");
    sb.append(
        "public class ProtegeIntrospector extends ReflectiveIntrospector {\n");
    sb.append("\n");
    sb.append(
        "  public void setOntology(ProtegeTools.ProtegeOntology onto) {\n");
    sb.append("    this.protegeOntology = onto;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  /**\n");
    sb.append("   *  Translate an object of a class representing an element in an ontology into\n");
    sb.append("   *  a proper abstract descriptor\n");
    sb.append("   *\n");
    sb.append("   *@param  obj                 The Object to be translated\n");
    sb.append(
        "   *@param  schema              The schema for the ontological element this\n");
    sb.append("   *      object is an instance of.\n");
    sb.append(
        "   *@param  javaClass           The class of the Object to be translated\n");
    sb.append("   *@param  referenceOnto       The reference ontology in the context of this\n");
    sb.append("   *      translation.\n");
    sb.append(
        "   *@return                     The Abstract descriptor produced by the\n");
    sb.append("   *      translation\n");
    sb.append(
        "   *@throws  OntologyException  If some error occurs during the translation\n");
    sb.append("   */\n");
    sb.append("  public AbsObject externalise(Object obj, ObjectSchema schema, Class javaClass, Ontology referenceOnto)\n");
    sb.append("     throws OntologyException {\n");
    sb.append("    String slotName = \" < unknown > \";\n");
    sb.append("    try {\n");
    sb.append("      AbsObject abs = schema.newInstance();\n");
    sb.append("      String[] names = schema.getNames();\n");
    sb.append("\n");
    sb.append("      // Loop on slots\n");
    sb.append("      for (int i = 0; i < names.length; ++i) {\n");
    sb.append("        slotName = names[i];\n");
    sb.append("        ObjectSchema slotSchema = schema.getSchema(slotName);\n");
    sb.append(
        "        String transLatedName = translateName(slotName, javaClass);\n");
    sb.append("        if (transLatedName != null) {\n");
    sb.append("          String methodName = \"get\" + transLatedName;\n");
    sb.append(
        "           // Retrieve the accessor method from the class and call it\n");
    sb.append("          Method getMethod = findMethodCaseInsensitive(methodName, javaClass);\n");
    sb.append("//          this.setOntology(referenceOnto);\n");
    sb.append("          AbsObject value = (AbsObject)this.invokeAccessorMethod(getMethod, obj);\n");
    sb.append("          if (value != null) {\n");
    sb.append("            AbsHelper.setAttribute(abs, slotName, value);\n");
    sb.append("          }\n");
    sb.append("        }\n");
    sb.append("      }\n");
    sb.append("\n");
    sb.append("      return abs;\n");
    sb.append("    } catch (OntologyException oe) {\n");
    sb.append("      throw oe;\n");
    sb.append("    } catch (Throwable t) {\n");
    sb.append("      throw new OntologyException(\"Schema and Java class do not match for the slot:\" + slotName + \" and class: \" + javaClass.getClass().toString(), t);\n");
    sb.append("    }\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  /**\n");
    sb.append(
        "   *  Translate an abstract descriptor into an object of a proper class\n");
    sb.append("   *  representing an element in an ontology\n");
    sb.append("   *\n");
    sb.append(
        "   *@param  abs                   The abstract descriptor to be translated\n");
    sb.append("   *@param  schema                The schema for the ontological element this\n");
    sb.append("   *      abstract descriptor is an instance of.\n");
    sb.append("   *@param  javaClass             The class of the Object to be produced by the\n");
    sb.append("   *      translation\n");
    sb.append("   *@param  referenceOnto         The reference ontology in the context of this\n");
    sb.append("   *      translation.\n");
    sb.append("   *@return                       The Java object produced by the translation\n");
    sb.append("   *@throws  UngroundedException  If the abstract descriptor to be translated\n");
    sb.append("   *      contains a variable\n");
    sb.append("   *@throws  OntologyException    If some error occurs during the translation\n");
    sb.append("   */\n");
    sb.append("  public Object internalise(AbsObject abs, ObjectSchema schema, Class javaClass, Ontology referenceOnto)\n");
    sb.append("     throws UngroundedException, OntologyException {\n");
    sb.append("\n");
    sb.append("    try {\n");
    sb.append("      Object obj = javaClass.newInstance();\n");
    sb.append("      String[] names = schema.getNames();\n");
    sb.append("\n");
    sb.append("      // LOOP on slots\n");
    sb.append("      for (int i = 0; i < names.length; ++i) {\n");
    sb.append("        String slotName = names[i];\n");
    sb.append("        AbsObject value = abs.getAbsObject(slotName);\n");
    sb.append("        if (value != null) {\n");
    sb.append(
        "          ObjectSchema slotSchema = schema.getSchema(slotName);\n");
    sb.append("\n");
    sb.append(
        "          String methodName = \"set\" + translateName(slotName, javaClass);\n");
    sb.append(
        "          // Retrieve the modifier method from the class and call it\n");
    sb.append("          Method setMethod = findMethodCaseInsensitive(methodName, javaClass);\n");
    sb.append("          this.invokeSetterMethod(setMethod, obj, value);\n");
    sb.append("        }\n");
    sb.append("      }\n");
    sb.append("\n");
    sb.append("      return obj;\n");
    sb.append("    } catch (OntologyException oe) {\n");
    sb.append("      throw oe;\n");
    sb.append("    } catch (InstantiationException ie) {\n");
    sb.append("      throw new OntologyException(\"Class \" + javaClass + \" can't be instantiated\", ie);\n");
    sb.append("    } catch (IllegalAccessException iae) {\n");
    sb.append("      throw new OntologyException(\"Class \" + javaClass + \" does not have an accessible constructor\", iae);\n");
    sb.append("    } catch (Throwable t) {\n");
    sb.append("      throw new OntologyException(\"Schema and Java class do not match\", t);\n");
    sb.append("    }\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  protected String translateName(String slotName) {\n");
    sb.append("    return ProtegeTools.firstUpper(ProtegeTools.toJavaStyleString(slotName));\n");
    sb.append("    /*\n");
    sb.append("     *  StringBuffer buff = new StringBuffer(slotName);\n");
    sb.append("     *  ProtegeTools.firstUpper(buff);\n");
    sb.append("     *  ProtegeTools.toJavaString(buff);\n");
    sb.append("     *  return buff.toString();\n");
    sb.append("     */\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append(
        "  private String translateName(String jadeName, Class javaClass) {\n");
    sb.append("    //System.out.print(\"Class: \" + javaClass.getName());\n");
    sb.append("    //System.out.print(\", jadeName: \" + jadeName);\n");
    sb.append(
        "    SlotHolder jadeSlot = new SlotHolder(javaClass.getName(), jadeName);\n");
    sb.append("    if (jadeSlot == null) {\n");
    sb.append("      return null;\n");
    sb.append("    }\n");
    sb.append("    SlotHolder methodKey = protegeOntology.getSlotNameFromJADEName(jadeSlot);\n");
    sb.append("    if (methodKey == null) {\n");
    sb.append("      return null;\n");
    sb.append("    }\n");
    sb.append(
        "    //System.out.println(\", methodKey: \" + methodKey.slotName);\n");
    sb.append("    return translateName(methodKey.slotName);\n");
    sb.append("  }\n");
    sb.append("  private ProtegeTools.ProtegeOntology protegeOntology;\n");
    sb.append("}\n");
    OntologyBeanGeneratorUtil.writeFile(dir + "/ProtegeIntrospector.java", sb.toString());
  }

}
/* Generated By:JavaCC: Do not edit this line. SLParser.java */
package jade.semantics.lang.sl.parser;

import jade.semantics.lang.sl.grammar.*;
import jade.semantics.lang.sl.tools.SL;
import jade.util.leap.HashMap;
import jade.util.leap.ArrayList;

//=============================================================
//                      Parser declaration
//=============================================================
public class SLParser implements SLParserConstants {
  static final String META_EXCEPTION_MESSAGE               = "Meta SL expressions are not allowed";
  static final String INCONSISTENT_META_OCCURRENCE_MESSAGE = "Inconsistent meta-reference occurrence";
  static final String INVALID_PREDICATE_MESSAGE            = "Invalid predicate";
  static final String INVALID_REFERENCE_CONTEXT_MESSAGE    = "Invalid context for reference";

  static final int FUNCTIONNAL_TERM                     = 0;
  static final int PREDICATE                            = 1;

  static final int CONTENT_EXPRESSION_REFERENCE         = 0;
  static final int FORMULA_REFERENCE                    = 1;
  static final int SYMBOL_REFERENCE                     = 2;
  static final int TERM_REFERENCE                       = 3;
  static final int VARIABLE_REFERENCE                   = 4;

  //------------------------------------------------------------
  // SLParser is a singleton
  //------------------------------------------------------------
  static SLParser _instance = null;

  static public SLParser getParser()
  {
      if ( _instance == null ) {
          _instance = new SLParser();
      }
      return _instance;
  }

  //------------------------------------------------------------
  // SLParser as a SLParser
  //------------------------------------------------------------
  boolean _extended = false;
  HashMap _metaReferences;

  public SLParser()
  {
      this(new java.io.InputStreamReader(System.in));
  }


    public synchronized ListOfFormula parseFormulas(java.io.Reader stream, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      initParser(extended);
      return ListOfFormula();
  }

  public synchronized ListOfFormula parseFormulas(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormulas(stream, false);
  }



  public synchronized Content parseContent(java.io.Reader stream, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      initParser(extended);
      return Content(new ArrayList());
  }

  public synchronized Content parseContent(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(stream, false);
  }

  public synchronized Content parseContent(String content, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(new java.io.StringReader(content), extended);
  }

  public synchronized Content parseContent(String content)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseContent(new java.io.StringReader(content));
  }

  public synchronized FunctionalTerm parseAgent(java.io.Reader stream, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      initParser(extended);
      return (FunctionalTerm)FunctionalTermOrPredicate(FUNCTIONNAL_TERM, new ArrayList(), 0);
  }

  public synchronized FunctionalTerm parseAgent(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(stream, false);
  }

  public synchronized FunctionalTerm parseAgent(String term, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(new java.io.StringReader(term), extended);
  }

  public synchronized FunctionalTerm parseAgent(String term)
      throws ParseException
  //------------------------------------------------------------
  {
        return parseAgent(new java.io.StringReader(term));
  }

  public synchronized Term parseTerm(java.io.Reader stream, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      initParser(extended);
      return Term(new ArrayList(), 0);
  }

  public synchronized Term parseTerm(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(stream, false);
  }

  public synchronized Term parseTerm(String term, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(new java.io.StringReader(term), extended);
  }

  public synchronized Term parseTerm(String term)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseTerm(new java.io.StringReader(term));
  }

  public synchronized Formula parseFormula(java.io.Reader stream, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      ReInit(stream);
      initParser(extended);
      return Formula(new ArrayList());
  }

  public synchronized Formula parseFormula(java.io.Reader stream)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(stream, false);
  }

  public synchronized Formula parseFormula(String formula, boolean extended)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(new java.io.StringReader(formula), extended);
  }

  public synchronized Formula parseFormula(String formula)
      throws ParseException
  //------------------------------------------------------------
  {
      return parseFormula(new java.io.StringReader(formula));
  }

  private void initParser(boolean extended) {
      _extended = extended;
      if (_metaReferences == null) _metaReferences = new HashMap();
      _metaReferences.clear();
  }

  private Variable getVariableFromContext(String varName, int quantifierIndex, ArrayList vars) {
      for (int i=vars.size() - 1 ; i>=quantifierIndex ; i--) {
          if (((Variable)vars.get(i)).lx_name().equals(varName)) {
              return (Variable)vars.get(i);
          }
      }
      Variable var = new VariableNode(varName);
      vars.add(var);
      return var;
  }

  private void restoreSize(ArrayList list, int size) {
      for (int i=list.size()-1 ; i>=size ; i--) {
          list.remove(i);
      }
  }

//=============================================================
//                       Rules declaration
//=============================================================

// -------------------------------------------------------------
  final public ListOfFormula ListOfFormula() throws ParseException {
    ListOfFormula list = new ListOfFormula();
    Formula formula;
    label_1:
    while (true) {
      formula = Formula(new ArrayList());
         list.add(formula);
         _metaReferences.clear();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case OBLIGATIONKW:
      case COUNTASKW:
      case INSTFACTKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Content Content(ArrayList variables) throws ParseException {
    ContentNode content = new ContentNode(new ListOfContentExpression());
    ContentExpression expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
      break;
    case CONTENTKW:
      jj_consume_token(CONTENTKW);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_2:
    while (true) {
      expression = ContentExpression(variables);
         content.as_expressions().add(expression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case EQUALSKW:
      case SEMICOLONKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case SOMEKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case OBLIGATIONKW:
      case COUNTASKW:
      case INSTFACTKW:
      case ACTIONKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(CLOSE_BRACKET);
        {if (true) return content;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ContentExpression ContentExpression(ArrayList variables) throws ParseException {
    ActionExpression action_expression;
    IdentifyingExpression identifying_expression;
    Formula formula;
    Node meta;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(CONTENT_EXPRESSION_REFERENCE);
           {if (true) return (MetaContentExpressionReferenceNode)meta;}
      break;
    case PIPEKW:
    case SEMICOLONKW:
    case ACTIONKW:
      action_expression = ActionExpression(variables);
            {if (true) return new ActionContentExpressionNode(action_expression);}
      break;
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case SOMEKW:
      identifying_expression = IdentifyingExpression(variables);
        {if (true) return new IdentifyingContentExpressionNode(identifying_expression);}
      break;
    case OPEN_BRACKET:
    case EQUALSKW:
    case BELIEVEKW:
    case UNCERTAINTYKW:
    case INTENTIONKW:
    case PERSISTENTGOALKW:
    case ORKW:
    case ANDKW:
    case NOTKW:
    case DONEKW:
    case TRUEKW:
    case EQUIVKW:
    case FALSEKW:
    case OBLIGATIONKW:
    case COUNTASKW:
    case INSTFACTKW:
    case RESULTKW:
    case EXISTSKW:
    case FORALLKW:
    case IMPLIESKW:
    case FEASIBLEKW:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      formula = Formula(variables);
            {if (true) return new FormulaContentExpressionNode(formula);}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ActionExpression ActionExpression(ArrayList variables) throws ParseException {
    Term left_action;
    Term right_action;
    Term agent;
    Term term;
    Term action;
    AlternativeActionExpressionNode alt;
    SequenceActionExpressionNode seq;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACTIONKW:
      jj_consume_token(ACTIONKW);
      agent = Term(variables, 0);
      term = Term(variables, 0);
      jj_consume_token(CLOSE_BRACKET);
         {if (true) return new ActionExpressionNode(agent, term);}
      break;
    case PIPEKW:
      jj_consume_token(PIPEKW);
      left_action = Term(variables, 0);
      right_action = Term(variables, 0);
        alt = new AlternativeActionExpressionNode(left_action, right_action);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
        case PIPEKW:
        case SEMICOLONKW:
        case CONTENTKW:
        case SETKW:
        case ALLKW:
        case ANYKW:
        case IOTAKW:
        case SOMEKW:
        case FACTKW:
        case ACTIONKW:
        case SEQUENCEKW:
        case VARIABLE:
        case META_VARIABLE:
        case INTEGER:
        case FLOAT:
        case DATE_TIME:
        case STRING_LITERAL:
        case WORD:
        case BYTES:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_3;
        }
        action = Term(variables, 0);
                alt = new AlternativeActionExpressionNode(alt, action);
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return alt;}
      break;
    case SEMICOLONKW:
      jj_consume_token(SEMICOLONKW);
      left_action = Term(variables, 0);
      right_action = Term(variables, 0);
        seq = new SequenceActionExpressionNode(left_action, right_action);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
        case PIPEKW:
        case SEMICOLONKW:
        case CONTENTKW:
        case SETKW:
        case ALLKW:
        case ANYKW:
        case IOTAKW:
        case SOMEKW:
        case FACTKW:
        case ACTIONKW:
        case SEQUENCEKW:
        case VARIABLE:
        case META_VARIABLE:
        case INTEGER:
        case FLOAT:
        case DATE_TIME:
        case STRING_LITERAL:
        case WORD:
        case BYTES:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_4;
        }
        action = Term(variables, 0);
                seq = new SequenceActionExpressionNode(seq, action);
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return seq;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public IdentifyingExpression IdentifyingExpression(ArrayList variables) throws ParseException {
    Term term;
    Formula formula;
    int varStackSize;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IOTAKW:
      jj_consume_token(IOTAKW);
          varStackSize = variables.size();
      term = Term(variables, varStackSize);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
          restoreSize(variables, varStackSize);
          {if (true) return new IotaNode(term, formula);}
      break;
    case ALLKW:
      jj_consume_token(ALLKW);
          varStackSize = variables.size();
      term = Term(variables, varStackSize);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
          restoreSize(variables, varStackSize);
          {if (true) return new AllNode(term, formula);}
      break;
    case ANYKW:
      jj_consume_token(ANYKW);
          varStackSize = variables.size();
      term = Term(variables, varStackSize);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
          restoreSize(variables, varStackSize);
          {if (true) return new AnyNode(term, formula);}
      break;
    case SOMEKW:
      jj_consume_token(SOMEKW);
          varStackSize = variables.size();
      term = Term(variables, varStackSize);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
          restoreSize(variables, varStackSize);
          {if (true) return new SomeNode(term, formula);}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Formula Formula(ArrayList variables) throws ParseException {
    AtomicFormula atomic_formula;
    Term action;
    Formula formula = null;
    Formula left_formula;
    Formula right_formula;
    AndNode and;
    OrNode or;
    Term agent;
    Variable variable;
    Node meta;
    int varStackSize;
    Term institution;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(FORMULA_REFERENCE);
           {if (true) return (MetaFormulaReferenceNode)meta;}
      break;
    case OPEN_BRACKET:
    case EQUALSKW:
    case TRUEKW:
    case FALSEKW:
    case RESULTKW:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      atomic_formula = AtomicFormula(variables);
             {if (true) return atomic_formula;}
      break;
    case DONEKW:
      jj_consume_token(DONEKW);
      action = Term(variables, 0);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case OBLIGATIONKW:
      case COUNTASKW:
      case INSTFACTKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        formula = Formula(variables);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new DoneNode(action, formula==null?SL.TRUE:formula);}
      break;
    case FEASIBLEKW:
      jj_consume_token(FEASIBLEKW);
      action = Term(variables, 0);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case EQUALSKW:
      case BELIEVEKW:
      case UNCERTAINTYKW:
      case INTENTIONKW:
      case PERSISTENTGOALKW:
      case ORKW:
      case ANDKW:
      case NOTKW:
      case DONEKW:
      case TRUEKW:
      case EQUIVKW:
      case FALSEKW:
      case OBLIGATIONKW:
      case COUNTASKW:
      case INSTFACTKW:
      case RESULTKW:
      case EXISTSKW:
      case FORALLKW:
      case IMPLIESKW:
      case FEASIBLEKW:
      case META_VARIABLE:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        formula = Formula(variables);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new FeasibleNode(action, formula==null?SL.TRUE:formula);}
      break;
    case NOTKW:
      jj_consume_token(NOTKW);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new NotNode(formula);}
      break;
    case ANDKW:
      jj_consume_token(ANDKW);
      left_formula = Formula(variables);
      right_formula = Formula(variables);
        and = new AndNode(left_formula, right_formula);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
        case EQUALSKW:
        case BELIEVEKW:
        case UNCERTAINTYKW:
        case INTENTIONKW:
        case PERSISTENTGOALKW:
        case ORKW:
        case ANDKW:
        case NOTKW:
        case DONEKW:
        case TRUEKW:
        case EQUIVKW:
        case FALSEKW:
        case OBLIGATIONKW:
        case COUNTASKW:
        case INSTFACTKW:
        case RESULTKW:
        case EXISTSKW:
        case FORALLKW:
        case IMPLIESKW:
        case FEASIBLEKW:
        case META_VARIABLE:
        case STRING_LITERAL:
        case WORD:
        case BYTES:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
        formula = Formula(variables);
        and = new AndNode(and, formula);
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return and;}
      break;
    case ORKW:
      jj_consume_token(ORKW);
      left_formula = Formula(variables);
      right_formula = Formula(variables);
        or = new OrNode(left_formula, right_formula);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
        case EQUALSKW:
        case BELIEVEKW:
        case UNCERTAINTYKW:
        case INTENTIONKW:
        case PERSISTENTGOALKW:
        case ORKW:
        case ANDKW:
        case NOTKW:
        case DONEKW:
        case TRUEKW:
        case EQUIVKW:
        case FALSEKW:
        case OBLIGATIONKW:
        case COUNTASKW:
        case INSTFACTKW:
        case RESULTKW:
        case EXISTSKW:
        case FORALLKW:
        case IMPLIESKW:
        case FEASIBLEKW:
        case META_VARIABLE:
        case STRING_LITERAL:
        case WORD:
        case BYTES:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        formula = Formula(variables);
                or = new OrNode(or, formula);
      }
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return or;}
      break;
    case IMPLIESKW:
      jj_consume_token(IMPLIESKW);
      left_formula = Formula(variables);
      right_formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ImpliesNode(left_formula, right_formula);}
      break;
    case EQUIVKW:
      jj_consume_token(EQUIVKW);
      left_formula = Formula(variables);
      right_formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new EquivNode(left_formula, right_formula);}
      break;
    case EXISTSKW:
      jj_consume_token(EXISTSKW);
        varStackSize = variables.size();
      variable = Variable(variables, varStackSize);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        restoreSize(variables, varStackSize);
        {if (true) return new ExistsNode(variable, formula);}
      break;
    case FORALLKW:
      jj_consume_token(FORALLKW);
        varStackSize = variables.size();
      variable = Variable(variables, varStackSize);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        restoreSize(variables, varStackSize);
        {if (true) return new ForallNode(variable, formula);}
      break;
    case BELIEVEKW:
      jj_consume_token(BELIEVEKW);
      agent = Term(variables, 0);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new BelieveNode(agent, formula);}
      break;
    case UNCERTAINTYKW:
      jj_consume_token(UNCERTAINTYKW);
      agent = Term(variables, 0);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new UncertaintyNode(agent, formula);}
      break;
    case INTENTIONKW:
      jj_consume_token(INTENTIONKW);
      agent = Term(variables, 0);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new IntentionNode(agent, formula);}
      break;
    case PERSISTENTGOALKW:
      jj_consume_token(PERSISTENTGOALKW);
      agent = Term(variables, 0);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new PersistentGoalNode(agent, formula);}
      break;
    case OBLIGATIONKW:
      jj_consume_token(OBLIGATIONKW);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
                {if (true) return new ObligationNode(formula);}
      break;
    case COUNTASKW:
      jj_consume_token(COUNTASKW);
      institution = Term(variables,0);
      left_formula = Formula(variables);
      right_formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
                {if (true) return new CountAsNode(institution,left_formula,right_formula);}
      break;
    case INSTFACTKW:
      jj_consume_token(INSTFACTKW);
      institution = Term(variables,0);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
                {if (true) return new InstitutionalFactNode(institution,formula);}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public AtomicFormula AtomicFormula(ArrayList variables) throws ParseException {
    Node predicate;
    Symbol symbol;
    Term term1, term2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      symbol = Symbol();
        {if (true) return new PropositionSymbolNode(symbol);}
      break;
    case RESULTKW:
      jj_consume_token(RESULTKW);
      term1 = Term(variables, 0);
      term2 = Term(variables, 0);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new ResultNode(term1, term2);}
      break;
    case EQUALSKW:
      jj_consume_token(EQUALSKW);
      term1 = Term(variables, 0);
      term2 = Term(variables, 0);
      jj_consume_token(CLOSE_BRACKET);
        {if (true) return new EqualsNode(term1, term2);}
      break;
    case OPEN_BRACKET:
      predicate = FunctionalTermOrPredicate(PREDICATE, variables, 0);
        {if (true) return (PredicateNode)predicate;}
      break;
    case TRUEKW:
      jj_consume_token(TRUEKW);
//        TrueNode trueNode = new TrueNode();
//        trueNode.sm_simplified_formula(trueNode);
        {if (true) return SL.TRUE;}
      break;
    case FALSEKW:
      jj_consume_token(FALSEKW);
//        FalseNode falseNode = new FalseNode();
//        falseNode.sm_simplified_formula(falseNode);
        {if (true) return SL.FALSE;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ListOfTerm Terms(ArrayList variables, int quantifierIndex) throws ParseException {
    ListOfTerm terms = new ListOfTerm();
    Term term;
    label_7:
    while (true) {
      term = Term(variables, quantifierIndex);
        terms.add(term);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case SEMICOLONKW:
      case CONTENTKW:
      case SETKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case SOMEKW:
      case FACTKW:
      case ACTIONKW:
      case SEQUENCEKW:
      case VARIABLE:
      case META_VARIABLE:
      case INTEGER:
      case FLOAT:
      case DATE_TIME:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_7;
      }
    }
       {if (true) return terms;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Symbol Symbol() throws ParseException {
    Node meta;
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(SYMBOL_REFERENCE);
                {if (true) return (MetaSymbolReferenceNode)meta;}
      break;
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        token = jj_consume_token(STRING_LITERAL);
        break;
      case BYTES:
        token = jj_consume_token(BYTES);
        break;
      case WORD:
        token = jj_consume_token(WORD);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                {if (true) return SL.symbol(token.image);}
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public String String() throws ParseException {
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
        {if (true) return token.image;}
      break;
    case BYTES:
      token = jj_consume_token(BYTES);
        {if (true) return token.image;}
      break;
    case WORD:
      token = jj_consume_token(WORD);
                {if (true) return token.image;}
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Term Term(ArrayList variables, int quantifierIndex) throws ParseException {
    Constant constant;
    TermSet term_set;
    TermSequence term_sequence;
    Node functional_term;
    ActionExpression action_expression;
    IdentifyingExpression identifying_expression;
    Variable variable;
    Content content;
    ContentExpression expression;
    Node meta;
    Formula formula;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(TERM_REFERENCE);
         {if (true) return (Term)meta;}
      break;
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      constant = Constant();
        {if (true) return constant;}
      break;
    case SETKW:
      term_set = TermSet(variables, quantifierIndex);
        {if (true) return term_set;}
      break;
    case SEQUENCEKW:
      term_sequence = TermSequence(variables, quantifierIndex);
        {if (true) return term_sequence;}
      break;
    case OPEN_BRACKET:
      functional_term = FunctionalTermOrPredicate(FUNCTIONNAL_TERM, variables, quantifierIndex);
        {if (true) return (FunctionalTerm)functional_term;}
      break;
    case PIPEKW:
    case SEMICOLONKW:
    case ACTIONKW:
      action_expression = ActionExpression(variables);
            {if (true) return action_expression;}
      break;
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case SOMEKW:
      identifying_expression = IdentifyingExpression(variables);
        {if (true) return identifying_expression;}
      break;
    case VARIABLE:
      variable = Variable(variables, quantifierIndex);
             {if (true) return variable;}
      break;
    case FACTKW:
      jj_consume_token(FACTKW);
      formula = Formula(variables);
      jj_consume_token(CLOSE_BRACKET);
                {if (true) return new FactNode(formula);}
      break;
    case CONTENTKW:
      jj_consume_token(CONTENTKW);
          content = new ContentNode(new ListOfContentExpression());
      label_8:
      while (true) {
        expression = ContentExpression(variables);
            content.as_expressions().add(expression);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_BRACKET:
        case PIPEKW:
        case EQUALSKW:
        case SEMICOLONKW:
        case BELIEVEKW:
        case UNCERTAINTYKW:
        case INTENTIONKW:
        case PERSISTENTGOALKW:
        case ORKW:
        case ANDKW:
        case NOTKW:
        case ALLKW:
        case ANYKW:
        case IOTAKW:
        case SOMEKW:
        case DONEKW:
        case TRUEKW:
        case EQUIVKW:
        case FALSEKW:
        case OBLIGATIONKW:
        case COUNTASKW:
        case INSTFACTKW:
        case ACTIONKW:
        case RESULTKW:
        case EXISTSKW:
        case FORALLKW:
        case IMPLIESKW:
        case FEASIBLEKW:
        case META_VARIABLE:
        case STRING_LITERAL:
        case WORD:
        case BYTES:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_8;
        }
      }
      jj_consume_token(CLOSE_BRACKET);
                {if (true) return content;}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Constant Constant() throws ParseException {
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      token = jj_consume_token(STRING_LITERAL);
        String s = token.image.substring(1,token.image.length()-1);
        String value = new String();
        for (int i=0; i<s.length(); i++) {
            if ( i<s.length()-1 &&
                 s.charAt(i) == '\\' &&
                 (s.charAt(i+1) == '\"' || s.charAt(i+1) == '\\' ) ) {
                i++;
            }
            value += s.charAt(i);
        }
        {if (true) return SL.string(value);}
      break;
    case WORD:
      token = jj_consume_token(WORD);
        if ( token.image.charAt(0) == '\'' ) {
               {if (true) return SL.word(token.image.substring(1, token.image.length()-1));}
            }
            else {
               {if (true) return SL.word(token.image);}
            }
      break;
    case BYTES:
      token = jj_consume_token(BYTES);
        int n = Integer.parseInt(token.image.substring(1, token.image.length()-1));
                char[] chars = new char[n];
                try {
                          jj_input_stream.readChars(chars);
//			  for (int i=0; i<n;i++) {chars[i] = jj_input_stream.readChar();}
// WARNING : the original call of readChar has been replaced by the call of a special
// method introduced by Vincent Louis and Thierry Martinez, called
// readChars, into the SimpleCharStream class. This method allows to read all characters
// of a byte constant in one single method invocation, which is really more efficient to read
// huge byte constants, such as images for example. 
// For safety reason, the SimpleCharStream.java file is also stored in a file
// called SimpleCharStream.java.dontoverride. This file can be used to recover the 
// readChars method if SimpleCharStream.java is regenerated by JavaCC.
// 
                }
                catch(Exception e) {e.printStackTrace();}
                {if (true) return SL.bytes(Base64.decode(chars));}
      break;
    case FLOAT:
      token = jj_consume_token(FLOAT);
        {if (true) return SL.real(token.image);}
      break;
    case INTEGER:
      token = jj_consume_token(INTEGER);
        {if (true) return SL.integer(token.image);}
      break;
    case DATE_TIME:
      token = jj_consume_token(DATE_TIME);
        {if (true) return SL.date(token.image);}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public TermSet TermSet(ArrayList variables, int quantifierIndex) throws ParseException {
    ListOfTerm terms = null;
    jj_consume_token(SETKW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case CONTENTKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case SOMEKW:
    case FACTKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      terms = Terms(variables, quantifierIndex);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
         {if (true) return new TermSetNode(terms==null ? new ListOfTerm() : terms);}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public TermSequence TermSequence(ArrayList variables, int quantifierIndex) throws ParseException {
    ListOfTerm terms = null;
    jj_consume_token(SEQUENCEKW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case CONTENTKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case SOMEKW:
    case FACTKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      terms = Terms(variables, quantifierIndex);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
         {if (true) return new TermSequenceNode(terms==null ? new ListOfTerm() : terms);}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Node FunctionalTermOrPredicate(int which, ArrayList variables, int quantifierIndex) throws ParseException {
    Symbol symbol;
    ListOfTerm terms = null;
    ListOfParameter parameters = null;
    jj_consume_token(OPEN_BRACKET);
    symbol = Symbol();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
    case PIPEKW:
    case SEMICOLONKW:
    case METAOPTIONKW:
    case CONTENTKW:
    case SETKW:
    case ALLKW:
    case ANYKW:
    case IOTAKW:
    case SOMEKW:
    case FACTKW:
    case ACTIONKW:
    case SEQUENCEKW:
    case PARAMETER_NAME:
    case VARIABLE:
    case META_VARIABLE:
    case INTEGER:
    case FLOAT:
    case DATE_TIME:
    case STRING_LITERAL:
    case WORD:
    case BYTES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case PIPEKW:
      case SEMICOLONKW:
      case CONTENTKW:
      case SETKW:
      case ALLKW:
      case ANYKW:
      case IOTAKW:
      case SOMEKW:
      case FACTKW:
      case ACTIONKW:
      case SEQUENCEKW:
      case VARIABLE:
      case META_VARIABLE:
      case INTEGER:
      case FLOAT:
      case DATE_TIME:
      case STRING_LITERAL:
      case WORD:
      case BYTES:
        terms = Terms(variables, quantifierIndex);
        break;
      case METAOPTIONKW:
      case PARAMETER_NAME:
        parameters = Parameters(variables, quantifierIndex);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(CLOSE_BRACKET);
        if ( which == FUNCTIONNAL_TERM ) {
            if ( parameters == null ) {
                if ( terms == null ) {
                                {if (true) return new FunctionalTermParamNode(symbol, new ListOfParameter());}
                }
                else {
                                {if (true) return new FunctionalTermNode(symbol, terms==null ? new ListOfTerm() : terms);}
                        }
            }
            else {
                        {if (true) return new FunctionalTermParamNode(symbol, parameters);}
            }
        }
        else /* which == PREDICATE */ {
            if ( parameters == null ) {
                        {if (true) return new PredicateNode(symbol, terms==null ? new ListOfTerm() : terms);}
            }
            else {
                        {if (true) throw new ParseException(INVALID_PREDICATE_MESSAGE);}
            }
        }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public ListOfParameter Parameters(ArrayList variables, int quantifierIndex) throws ParseException {
    ListOfParameter parameters = new ListOfParameter();
    Parameter parameter;
    label_9:
    while (true) {
      parameter = Parameter(variables, quantifierIndex);
        parameters.add(parameter);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case METAOPTIONKW:
      case PARAMETER_NAME:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_9;
      }
    }
       {if (true) return parameters;}
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Parameter Parameter(ArrayList variables, int quantifierIndex) throws ParseException {
    Token token;
    Term term;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARAMETER_NAME:
      token = jj_consume_token(PARAMETER_NAME);
      term = Term(variables, quantifierIndex);
          {if (true) return new ParameterNode(term, token.image.substring(1), Boolean.FALSE);}
      break;
    case METAOPTIONKW:
      jj_consume_token(METAOPTIONKW);
      token = jj_consume_token(PARAMETER_NAME);
      term = Term(variables, quantifierIndex);
      jj_consume_token(CLOSE_BRACKET);
                if ( !_extended ) {{if (true) throw new ParseException(META_EXCEPTION_MESSAGE);}}
                {if (true) return new ParameterNode(term, token.image.substring(1), Boolean.TRUE);}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Variable Variable(ArrayList variables, int quantifierIndex) throws ParseException {
    Node meta;
    Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case META_VARIABLE:
      meta = MetaVariable(VARIABLE_REFERENCE);
         {if (true) return (MetaVariableReferenceNode)meta;}
      break;
    case VARIABLE:
      token = jj_consume_token(VARIABLE);
        {if (true) return getVariableFromContext(token.image.substring(1), quantifierIndex, variables);}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// -------------------------------------------------------------
  final public Node MetaVariable(int which) throws ParseException {
    Token token;
    token = jj_consume_token(META_VARIABLE);
         if ( !_extended ) {{if (true) throw new ParseException(META_EXCEPTION_MESSAGE);}}

         String metaReferenceName = token.image.substring(2);
         Node metaReference = (Node)_metaReferences.get(metaReferenceName);

         if ( which == CONTENT_EXPRESSION_REFERENCE ) {
             if (metaReference == null) {
                 MetaContentExpressionReferenceNode result = new MetaContentExpressionReferenceNode(metaReferenceName);
                 _metaReferences.put(metaReferenceName, result);
                 {if (true) return result;}
             }
             else {
                 if (metaReference instanceof MetaContentExpressionReferenceNode) {
                     {if (true) return metaReference;}
                 }
                 else {if (true) throw new ParseException(INCONSISTENT_META_OCCURRENCE_MESSAGE + " ??" + metaReferenceName);}
             }
         }
         else if ( which == FORMULA_REFERENCE ) {
             if (metaReference == null) {
                 MetaFormulaReferenceNode result = new MetaFormulaReferenceNode(metaReferenceName);
                 _metaReferences.put(metaReferenceName, result);
                 {if (true) return result;}
             }
             else {
                 if (metaReference instanceof MetaFormulaReferenceNode) {
                     {if (true) return metaReference;}
                 }
                 else {if (true) throw new ParseException(INCONSISTENT_META_OCCURRENCE_MESSAGE + " ??" + metaReferenceName);}
             }
         }
         else if ( which == SYMBOL_REFERENCE ) {
             if (metaReference == null) {
                 MetaSymbolReferenceNode result = new MetaSymbolReferenceNode(metaReferenceName);
                 _metaReferences.put(metaReferenceName, result);
                 {if (true) return result;}
             }
             else {
                 if (metaReference instanceof MetaSymbolReferenceNode) {
                     {if (true) return metaReference;}
                 }
                 else {if (true) throw new ParseException(INCONSISTENT_META_OCCURRENCE_MESSAGE + " ??" + metaReferenceName);}
             }
         }
         else if ( which == TERM_REFERENCE ) {
             if (metaReference == null) {
                 MetaTermReferenceNode result = new MetaTermReferenceNode(metaReferenceName);
                 _metaReferences.put(metaReferenceName, result);
                 {if (true) return result;}
             }
             else {
                 if (metaReference instanceof MetaTermReferenceNode || metaReference instanceof MetaVariableReferenceNode) {
                     {if (true) return metaReference;}
                 }
                 else {if (true) throw new ParseException(INCONSISTENT_META_OCCURRENCE_MESSAGE + " ??" + metaReferenceName);}
             }
         }
         else if ( which == VARIABLE_REFERENCE ) {
             if (metaReference == null) {
                 MetaVariableReferenceNode result = new MetaVariableReferenceNode(metaReferenceName);
                 _metaReferences.put(metaReferenceName, result);
                 {if (true) return result;}
             }
             else {
                 if (metaReference instanceof MetaVariableReferenceNode || metaReference instanceof MetaTermReferenceNode) {
                     {if (true) return metaReference;}
                 }
                 else {if (true) throw new ParseException(INCONSISTENT_META_OCCURRENCE_MESSAGE + " ??" + metaReferenceName);}
             }
         }
         else {
             {if (true) throw new ParseException(INVALID_REFERENCE_CONTEXT_MESSAGE);}
         }
    throw new Error("Missing return statement in function");
  }

  public SLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[28];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xe0fd1200,0x20200,0xfefd3a00,0xfefd3a00,0x1f022a00,0x1f022a00,0x2800,0x1e000000,0xe0fd1200,0xe0fd1200,0xe0fd1200,0xe0fd1200,0xe0fd1200,0x40001200,0x1f022a00,0x0,0x0,0x0,0xfefd3a00,0x1f022a00,0x0,0x1f022a00,0x1f022a00,0x1f02aa00,0x1f02aa00,0x8000,0x8000,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0xc00047cf,0x0,0xc00047ef,0xc00047ef,0xc024e830,0xc024e830,0x20,0x0,0xc00047cf,0xc00047cf,0xc00047cf,0xc00047cf,0xc00047cf,0xc0004041,0xc024e830,0xc0000000,0xc0004000,0xc0000000,0xc00047ef,0xc024e830,0xc0248000,0xc024e830,0xc024e830,0xc024f830,0xc024f830,0x1000,0x1000,0x6000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x1,0x0,0x1,0x1,0x1,0x1,0x0,0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x0,0x0,};
   }

  public SLParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  public SLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  public SLParser(SLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  public void ReInit(SLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[68];
    for (int i = 0; i < 68; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 28; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 68; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}

/*****************************************************************
JADE - Java Agent DEvelopment Framework is a framework to develop 
multi-agent systems in compliance with the FIPA specifications.
JSA - JADE Semantics Add-on is a framework to develop cognitive
agents in compliance with the FIPA-ACL formal specifications.

Copyright (C) 2007 France Telecom

GNU Lesser General Public License

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation, 
version 2.1 of the License. 

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA  02111-1307, USA.
*****************************************************************/

package jade.semantics.behaviours;

/*
 * PlanPerformanceBehaviour.java
 * Created on 6 November 2007
 * Author : Carole Adam, Vincent Louis
 */

import jade.core.behaviours.Behaviour;
import jade.core.behaviours.SequentialBehaviour;
import jade.lang.acl.ACLMessage;
import jade.semantics.interpreter.SemanticCapabilities;
import jade.semantics.interpreter.SemanticInterpretationException;
import jade.semantics.interpreter.SemanticRepresentation;
import jade.semantics.kbase.QueryResult;
import jade.semantics.kbase.observers.Observer;
import jade.semantics.kbase.observers.ObserverAdapter;
import jade.semantics.lang.sl.grammar.ActionExpression;
import jade.semantics.lang.sl.grammar.Formula;
import jade.semantics.lang.sl.grammar.ListOfTerm;
import jade.semantics.lang.sl.grammar.PredicateNode;
import jade.semantics.lang.sl.grammar.Term;
import jade.semantics.lang.sl.tools.SL;
import jade.util.leap.ArrayList;

/**
 * This behaviour is installed by the PlanExecutionSIP 
 * (subclass of PlanProcessingSIPAdapter)
 * that handles the <code>(is_doing ??agent ??PLAN)</code> SR 
 * generated by the planning SIPs.
 * 
 * It manages this plan and its annotations: it interprets the annotations
 * corresponding to the ending state of the behaviour.
 * 
 * @author Carole Adam - France Telecom
 * @version Date: 2007/11/06 Revision: 1.0
 */
public class PlanPerformanceBehaviour extends SequentialBehaviour implements SemanticBehaviour {
    
    
    /**
     * The plan that the agent is doing
     */
    private ActionExpression plan;
	
	/**
	 * The capabilities of the holder agent.
	 */
	private SemanticCapabilities myCapabilities;
	
	/**
	 * The semantic behaviour to perform, 
	 * computed from the received plan.
	 */
	private SemanticBehaviour planBehaviour;
	
	/**
	 * The ArrayList of Observers for these formulas, that are created in the constructor,
	 * and installed in the onStart() method.
	 */
	private ArrayList cancellingObservers;
		
	/**
	 * The SRs to interpret when the plan succeeds.
	 * ArrayList of SemanticRepresentation elements.
	 * It is the annotation associated with the tag SR.REACHED_GOAL_KEY
	 */
	private ArrayList successSRs;
	
	/**
	 * The SRs to interpret when the plan falls in execution failure.
	 * ArrayList of SemanticRepresentation elements.
	 * It is the annotation associated with the tag SR.EXECUTION_FAILURE_KEY
	 */
	private ArrayList executionFailureSRs;
	
	/**
	 * The SRs to interpret when the plan falls in feasibility failure.
	 * ArrayList of SemanticRepresentation elements.
	 * It is the annotation associated with the tag SR.FEASIBILITY_FAILURE_KEY
	 */
	private ArrayList feasibilityFailureSRs;
	
	private SemanticBehaviour waitingBehaviour;
	
	private Formula intendedGoal;
	    
    /*********************************************************************/
    /**                         CONSTRUCTOR                             **/
    /*********************************************************************/
    
    /**
     * Creates a PlanPerformanceBehaviour on the given plan.
     * Manages only three SR that are to be interpreted depending
     * on the execution of the plan (one SR for each possible ending state)
     * 
     * @param plan the plan to execute
     * @param successSRs the SR to be interpreted when the plan succeeds
     * @param executionFailureSRs the SR to be interpreted in execution failure state
     * @param feasibilityFailureSRs the SR to be interpreted in feasibility failure state
     * @param capabilities the capabilities of the owner agent
     */   
    public PlanPerformanceBehaviour(ActionExpression plan,
    								ArrayList successSRlist, 
    								ArrayList executionFailureSRlist, 
    								ArrayList feasibilityFailureSRlist,
    								SemanticCapabilities capabilities) {
		this.myCapabilities = capabilities;

    	// Do a simplify processing (not all annotations are available).
    	// Unavailable annotations stay null and are not processed.
		// (no pre- and post-processing of plan, no cancelling observers) 
//		this.cancellingFormulas = null;
		this.cancellingObservers = null;
	    // available annotations
        this.executionFailureSRs = executionFailureSRlist;
        this.feasibilityFailureSRs = feasibilityFailureSRlist;
        this.successSRs = successSRlist;  
        
        // initialisation of plan
        this.plan = plan;

        init(this.plan, null, null);
    }

    
    public PlanPerformanceBehaviour(
    		ActionExpression thePlan,
    		SemanticRepresentation isDoingSR,
    		SemanticCapabilities capabilities) {
    	
    	this.myCapabilities = capabilities;
    	this.executionFailureSRs = (ArrayList) isDoingSR.getAnnotation(SemanticRepresentation.INTERPRET_ON_PLAN_EXCEPTION_KEY);
    	this.feasibilityFailureSRs = (ArrayList) isDoingSR.getAnnotation(SemanticRepresentation.INTERPRET_ON_PLAN_FAILURE_KEY);
    	this.waitingBehaviour = (SemanticBehaviour)isDoingSR.getAnnotation(SemanticRepresentation.WAITING_BEHAVIOUR_KEY);
    	this.intendedGoal = (Formula)isDoingSR.getAnnotation(SemanticRepresentation.GOAL_KEY);

//  	initialisation of attributes from annotations
    	ArrayList cancellingFormulas; 
    	cancellingFormulas = (ArrayList) isDoingSR.getAnnotation(SemanticRepresentation.CANCEL_ON_KEY);

    	this.successSRs = (ArrayList)isDoingSR.getAnnotation(SemanticRepresentation.INTERPRET_ON_PLAN_SUCCESS_KEY);
    	Formula formula = (Formula)isDoingSR.getAnnotation(SemanticRepresentation.INTERPRET_ON_REACHED_GOAL_KEY);
    	if (formula != null) {
    		SemanticRepresentation successSR = new SemanticRepresentation(formula);
    		successSR.setMessage(isDoingSR.getMessage());
    		if (this.successSRs == null) {
    			this.successSRs = new ArrayList(1);
    		}
    		this.successSRs.add(successSR);
    	}

//  	Before plan must be executed just once on the first attempt to achieve the intention
//  	so the beforePlan annotation is removed in order not to do again the prePlan before 
//  	another plan if the current plan fails
    	this.plan = thePlan;
//    	ActionExpression actualPlan = this.plan;
//    	goal = (Formula)isDoingSR.removeAnnotation(SemanticRepresentation.ACHIEVE_BEFORE_KEY);
//    	if (goal != null) {
//    		try {
//    			actualPlan = new SequenceActionExpressionNode(
//    					new AlternativeActionExpressionNode(
//    							(ActionExpression)SL.instantiate(ACHIEVE,
//    									"myself", capabilities.getAgentName(),
//    									"goal", new StringConstantNode(goal.toString())),
//    							SUCCEED),
//    					this.plan);
//    		}
//    		catch (WrongTypeException e) {
//    			e.printStackTrace();
//    		}
//    	}

    	init(this.plan, cancellingFormulas, isDoingSR.getMessage());
    }
    
    private void init(final ActionExpression actualPlan, ArrayList cancellingFormulas, ACLMessage inReplyTo) {
		setBehaviourName("Performance of plan: " + this.plan);

		try {
			this.planBehaviour = (SemanticBehaviour)this.myCapabilities.getMySemanticActionTable().getSemanticActionInstance(actualPlan).getBehaviour();
			if (inReplyTo != null) {
				this.planBehaviour.putAnnotation(SemanticBehaviour.IN_REPLY_TO_KEY, inReplyTo);
			}
			if (this.waitingBehaviour != null) {
				this.planBehaviour.putAnnotation(SemanticBehaviour.WAITING_BEHAVIOUR_KEY, this.waitingBehaviour);
			}
			addSubBehaviour((Behaviour)this.planBehaviour);
		}
		catch (SemanticInterpretationException sie) {
			setState(FEASIBILITY_FAILURE);
			return;
		}

		// scan the cancelling formulas and install an observer for each one
		if (cancellingFormulas != null) {
			cancellingObservers = new ArrayList(cancellingFormulas.size());
			for (int i=0;i<cancellingFormulas.size();i++) {
				cancellingObservers.add(new ObserverAdapter(myCapabilities.getMyKBase(),(Formula)cancellingFormulas.get(i)) {
					@Override
					public void action(QueryResult listOfMatchResults) {
						PlanPerformanceBehaviour.this.setState(CANCELLATION);
						PlanPerformanceBehaviour.this.onEnd();
						// TODO tag the behaviour with the reason why the plan is cancelled
						// removes the plan performance behaviour that was executing the cancelled plan
						PlanPerformanceBehaviour.this.myAgent.removeBehaviour(PlanPerformanceBehaviour.this);
					}
				});
			}
		}
    }
        
    /*************************************
     **           ACCESSORS             **
     *************************************/
    
    public SemanticCapabilities getMyCapabilities() {
    	return myCapabilities;
    }
    
        
    /*********************************************************************/
    /**                         PUBLIC METHODS                          **/
    /*********************************************************************/

    @Override
	public void onStart() {
    	// scan the observers array, install AND initialise each one
    	if (cancellingObservers != null) {
    		for (int i=0;i<cancellingObservers.size();i++) {
    			Observer o = (Observer) cancellingObservers.get(i);
    			getMySemanticCapabilities().getMyKBase().addObserver(o);
    			// do not forget do initialise the observer !
    			o.update(null);
    		}//end for
    	}//end if
    }//end onStart
    
    /**
     * At the end of the behaviour, get its ending state and interprets the suitable SR array.
     * Also removes all observers, and retract the (B agent (is_doing agent plan)) and the
     * (I agent (done plan)) formulas.
     *  
     * @return 0
     * @see jade.core.behaviours.Behaviour#onEnd()
     */
    @Override
	public int onEnd() {
    	// To end properly with the cancelling observers
    	if (cancellingObservers != null) {
    	for (int j=0;j<cancellingObservers.size();j++) {
			myCapabilities.getMyKBase().removeObserver((Observer)cancellingObservers.get(j));
		}}
        
    	// retract the (B agent (is_doing agent plan)) formula
    	myCapabilities.getMyKBase().retractFormula(
    								new PredicateNode(
										SL.symbol("is_doing"),
										new ListOfTerm(new Term[] {myCapabilities.getAgentName(),plan})));
    	// retract the intention related to this plan performance, if any
    	if (this.intendedGoal != null) {
    		myCapabilities.getMyKBase().retractFormula(this.intendedGoal);
    	}
//    	/* also retract the intention to perform the plan (different from the intention 
//    	 * to reach a goal, that is retracted by the interpretation of successSR)
//    	 */ 
//    	/** TODO check if it is really different !! **/
//    	getMySemanticCapabilities().interpret(
//    							new NotNode(
//    								new IntentionNode(
//    									myCapabilities.getAgentName(),
//    									new DoneNode(plan,SL.TRUE))));
//    	
        // To go on depending on the result of the behaviour
        if ((getState() == SUCCESS) && (successSRs != null)) {
        	getMySemanticCapabilities().interpret(successSRs);
        } 
        else if ((getState() == FEASIBILITY_FAILURE) && (feasibilityFailureSRs != null)) {
        	Object failureReason = getAnnotation(SemanticBehaviour.FAILURE_REASON_KEY);
        	if (failureReason != null) {
        		SemanticRepresentation.putAnnotation(feasibilityFailureSRs,
        				SemanticRepresentation.REASON_WHY_UNREACHED_KEY,
        				failureReason);
        	}
        	getMySemanticCapabilities().interpret(feasibilityFailureSRs);
        }
        else if ((getState() == EXECUTION_FAILURE) && (executionFailureSRs != null)) {
        	Object failureReason = getAnnotation(SemanticBehaviour.FAILURE_REASON_KEY);
        	if (failureReason != null) {
        		SemanticRepresentation.putAnnotation(feasibilityFailureSRs,
        				SemanticRepresentation.REASON_WHY_UNREACHED_KEY,
        				failureReason);
        	}
        	getMySemanticCapabilities().interpret(executionFailureSRs);
        }
        
		if (this.waitingBehaviour != null) {
			this.waitingBehaviour.setState(getState());
			if (getState() != SUCCESS) {
				Object failureReason = getAnnotation(SemanticBehaviour.FAILURE_REASON_KEY);
				if (failureReason != null) {
					this.waitingBehaviour.putAnnotation(
							SemanticBehaviour.FAILURE_REASON_KEY,
							failureReason);
				}
			}
			// Wake the waiting behaviour
			PlanPerformanceBehaviour.this.myAgent.addBehaviour((Behaviour)PlanPerformanceBehaviour.this.waitingBehaviour);
		}
		return 0;
    } 
    
    /**
     * Checks the termination of the behaviour
     * @return true if the state of the behaviour is <code>SUCCESS</code>, 
     * <code>FEASIBILITY_FAILURE</code>, or <code>EXECUTION_FAILURE</code>.
     * @see jade.core.behaviours.CompositeBehaviour#checkTermination(boolean, int)
     */
    @Override
	protected boolean checkTermination(boolean currentDone, int currentResult) {
        return (getState() == SUCCESS || getState() == FEASIBILITY_FAILURE
        		|| getState() == EXECUTION_FAILURE || getState() == CANCELLATION);
    } 
    
    /**
     * Sets the state of the semantic behaviour
     * @param state the state
     */
    public void setState(int state) {
    	if (planBehaviour != null) {
    		planBehaviour.setState(state);
    	}
//    	else {
//    		System.out.println("PlanPerformanceBehaviour.setState(): planBehaviour=null");
//    	}
    } 
    
    /**
     * Returns the state of the behaviour
     * @return the state of the behaviour
     */
    public int getState() {
    	if ( planBehaviour != null ) {
    		return planBehaviour.getState();
    	}
    	//else {
    		return FEASIBILITY_FAILURE;
    	//}
    } 
    
	/* (non-Javadoc)
	 * @see jade.semantics.behaviours.SemanticBehaviour#getMySemanticCapabilities()
	 */
	public SemanticCapabilities getMySemanticCapabilities() {
		return myCapabilities;
	}

	/* (non-Javadoc)
     * @see jade.semantics.behaviours.SemanticBehaviour#getAnnotation(java.lang.String)
     */
    public Object getAnnotation(String key) {
    	return root().getDataStore().get(key);
    }
    
    /* (non-Javadoc)
     * @see jade.semantics.behaviours.SemanticBehaviour#putAnnotation(java.lang.String, java.lang.Object)
     */
    public void putAnnotation(String key, Object value) {
    	root().getDataStore().put(key, value);
    }
} 
